# Generated by CodiumAI
import pandas
import numpy
from cmath import nan
from pathlib import Path
from src.training.preprocessing import (
    preprocessing_bathrooms,
    preprocessing_target,
    preprocessing,
)
import pytest
from pandas.api.types import CategoricalDtype


class TestPreprocessingBathrooms:
    # The function should be able to handle a pandas series with valid bathroom text information and return a pandas series with the number of baths in float format.
    def test_valid_bathroom_text(self):
        # Arrange
        bathrooms_text = pandas.Series(["1 bath", "1.5 baths", "2 baths"])
        expected_result = pandas.Series([1.0, 1.5, 2.0], dtype=float)

        # Act
        result = preprocessing_bathrooms(bathrooms_text)

        # Assert
        assert result.equals(expected_result)

    # The function should be able to handle a pandas series with only one valid bathroom text information and return a pandas series with the number of baths in float format.
    def test_single_valid_bathroom_text(self):
        # Arrange
        bathrooms_text = pandas.Series(["1 bath"])
        expected_result = pandas.Series([1.0], dtype=float)

        # Act
        result = preprocessing_bathrooms(bathrooms_text)

        # Assert
        assert result.equals(expected_result)

    # The function should return a pandas series with NaN values in float format when given a pandas series with only invalid bathroom text information.
    def test_invalid_bathroom_text(self):
        # Arrange
        bathrooms_text = pandas.Series(["invalid", "invalid", "invalid"])
        expected_result = pandas.Series([nan, nan, nan], dtype=float)

        # Act
        result = preprocessing_bathrooms(bathrooms_text)

        # Assert
        assert result.equals(expected_result)

    # The function should return a pandas series with NaN values in float format when given a pandas series with a mix of valid and invalid bathroom text information.
    def test_mix_valid_invalid_bathroom_text(self):
        # Arrange
        bathrooms_text = pandas.Series(["1 bath", "invalid", "2 baths"])
        expected_result = pandas.Series([1.0, nan, 2.0], dtype=float)

        # Act
        result = preprocessing_bathrooms(bathrooms_text)

        # Assert
        assert result.equals(expected_result)


class TestPreprocessingTarget:
    # Should return a pandas series with dtype int
    def test_return_series_with_dtype_int(self):
        # Arrange
        input_series = pandas.Series(
            [
                "$150.00",
                "$75.00",
                "$60.00",
                "$275.00",
                "$68.00",
                "$98.00",
                "$89.00",
                "$65.00",
                "$62.00",
                "$90.00",
                "$199.00",
                "$96.00",
            ]
        )
        expected_output = pandas.Series(
            [150, 75, 60, 275, 68, 98, 89, 65, 62, 90, 199, 96], dtype=int
        )

        # Act
        output_series = preprocessing_target(input_series)

        # Assert
        assert output_series.equals(expected_output)

    # Should remove the dollar sign from the input series
    # Should remove outliers below 10 dollars
    def test_remove_outliers_below_10_dollars(self):
        # Arrange
        input_series = pandas.Series(["$150.00", "$75.00", "$60.00", "$5.00", "$8.00"])
        expected_output = pandas.Series([150, 75, 60], dtype=int)

        # Act
        output_series = preprocessing_target(input_series)

        # Assert
        assert output_series.equals(expected_output)

    # Should return an empty series when input is an empty series
    def test_return_empty_series_when_input_is_empty(self):
        # Arrange
        input_series = pandas.Series([])
        expected_output = pandas.Series([], dtype=int)

        # Act
        output_series = preprocessing_target(input_series)

        # Assert
        assert output_series.equals(expected_output)

    # Should raise an error. None or Nan are not allowed
    def test_raise_exception_when_input_contains_null_values(self):
        # Arrange
        input_series = pandas.Series([None, None, None])

        # Act and raises
        with pytest.raises(TypeError):
            preprocessing_target(input_series)

    # Should raise an error. None or Nan are not allowed
    def test_raise_exception_when_input_contains_nan_values(self):
        # Arrange
        input_series = pandas.Series([nan, nan, nan])

        # Act and raises
        with pytest.raises(AttributeError):
            preprocessing_target(input_series)

    # Should raise an error. Only valid strings. Should be cleaned before
    def test_raise_exception_when_input_contains_strings_without_numbers(self):
        # Arrange
        input_series = pandas.Series(["$", "dollar", "price"])

        # Act and raises
        with pytest.raises(ValueError):
            preprocessing_target(input_series)


class TestPreprocessing:
    DIR_REPO = Path(__file__).resolve().parent
    DIR_DATA_RAW = Path(DIR_REPO) / "data" / "raw"
    DIR_DATA_PREPROCESSED = Path(DIR_REPO) / "data" / "processed"
    RAW_FILEPATH_DATA = DIR_DATA_RAW / "listings.csv"
    PREPROCESSED_FILEPATH_DATA = DIR_DATA_PREPROCESSED / "preprocessed_listings.csv"
    RAW_TEST_DATA = pandas.read_csv(RAW_FILEPATH_DATA, low_memory=False)
    PREPROCESSED_TEST_DATA = pandas.read_csv(
        PREPROCESSED_FILEPATH_DATA,
        low_memory=False,
        dtype={"category": CategoricalDtype(categories=[0, 1, 2, 3], ordered=True)},
    )

    # Given a valid pandas DataFrame with all necessary columns, the function should return a preprocessed DataFrame with transformed and cleaned data.
    def test_valid_dataframe(self):
        # Arrange

        # Act
        result = preprocessing(
            self.RAW_TEST_DATA, bins=[0, 90, 180, 400, numpy.inf], labels=[0, 1, 2, 3]
        )

        # Assert
        pandas.testing.assert_frame_equal(
            result.reset_index(drop=True),
            self.PREPROCESSED_TEST_DATA.reset_index(drop=True),
        )

    # TODO: Add more tests. No need to test again bathrooms and target value function
